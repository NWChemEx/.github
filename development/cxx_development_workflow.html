<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C++ Development Workflow &mdash; DeveloperTools 1.0.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Using IDEs to Develop NWX" href="ides/index.html" />
    <link rel="prev" title="Preliminaries" href="preliminaries.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> DeveloperTools
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../conventions/index.html">Project Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/index.html">Design Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developing NWChemEx</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="preliminaries.html">Preliminaries</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">C++ Development Workflow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#developing-a-module-without-submodules">Developing a Module without Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#developing-a-module-with-submodule-s">Developing a Module with Submodule(s)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#running-the-module">Running the Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unit-testing-the-module">Unit Testing the Module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ides/index.html">Using IDEs to Develop NWX</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../project_management/index.html">Project Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/index.html">Additional Developer Resources</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DeveloperTools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Developing NWChemEx</a> &raquo;</li>
      <li>C++ Development Workflow</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/development/cxx_development_workflow.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="c-development-workflow">
<h1>C++ Development Workflow<a class="headerlink" href="#c-development-workflow" title="Permalink to this heading"></a></h1>
<p>This page assumes you have already read
<a class="reference internal" href="preliminaries.html#development-preliminaries"><span class="std std-ref">Preliminaries</span></a> and that you are adding a module to a repo
which is considered part of NWChemEx (see <span class="xref std std-ref">software_stack_overview</span> for
more clarification on what’s part of NWChemEx and what’s not). If you are
developing a plugin for NWChemEx you should follow the documentation at xxx.</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Write plugin documentation and link to it</p>
</div>
<p>Adding new features to NWChemEx is accomplished by adding new modules. NWChemEx
relies on a plugin-based architecture and module development follows a
more-or-less traditional plugin development cycle. This means you write your
module’s source code largely decoupled from the rest of NWChemEx. When you need
to get a quantity that your module does not know how to compute (and is not an
input) you call out to a submodule. You do not have to write the submodule you
call (unless it’s not available in any other repo). Providing your module with
the submodule will happen at runtime.</p>
<p>Module development looks a little different depending on whether your module
needs to call a submodule or not. The former is the easier scenario</p>
<section id="developing-a-module-without-submodules">
<h2>Developing a Module without Submodules<a class="headerlink" href="#developing-a-module-without-submodules" title="Permalink to this heading"></a></h2>
<p>This can be done largely as you would expect. You add your source code to the
repo, add a unit test for your module’s source code, and then make sure the unit
test works.</p>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>Make this into a true tutorial.</p>
</div>
</section>
<section id="developing-a-module-with-submodule-s">
<h2>Developing a Module with Submodule(s)<a class="headerlink" href="#developing-a-module-with-submodule-s" title="Permalink to this heading"></a></h2>
<p>Development gets a bit more hairy when your module depends on a submodule (and
those submodules are not part of the current repo). For concreteness let’s
assume we are writing a module called <code class="docutils literal notranslate"><span class="pre">JCanonical</span></code> which does a naive
canonical J build. The source file for such a module will live in the SCF repo
and will have the path <code class="docutils literal notranslate"><span class="pre">nwx_workspace/SCF/src/scf/j_canonical.cpp</span></code>. The
contents of this source file could be something like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;scf/property_types.hpp&quot;</span><span class="c1"> // List of property types used in SCF repo</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;scf/scf_modules.hpp&quot;</span><span class="c1"> // Declarations of SCF modules, including ours</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;scf/types.hpp&quot;</span><span class="c1">       // types of objects used in SCF repo</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">scf</span><span class="w"> </span><span class="p">{</span><span class="w"></span>


<span class="w"> </span><span class="n">MODULE_CTOR</span><span class="p">(</span><span class="n">JCanonical</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="c1">// Our module knows how to compute J</span>
<span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">j_prop_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pt</span><span class="o">::</span><span class="n">coulomb</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="o">::</span><span class="n">derived_space_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="n">satisfies_property_type</span><span class="o">&lt;</span><span class="n">j_prop_type</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">     </span><span class="n">add_submodule</span><span class="o">&lt;</span><span class="n">pt</span><span class="o">::</span><span class="n">eri4c</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">&quot;ERI Builder&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="p">.</span><span class="n">set_description</span><span class="p">(</span><span class="s">&quot;Computes 4C ERI integrals&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="n">MODULE_RUN</span><span class="p">(</span><span class="n">JCanonical</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">j_prop_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pt</span><span class="o">::</span><span class="n">coulomb</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="o">::</span><span class="n">derived_space_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">mol</span><span class="p">,</span><span class="w"> </span><span class="n">MOs</span><span class="p">,</span><span class="w"> </span><span class="n">bra</span><span class="p">,</span><span class="w"> </span><span class="n">ket</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j_prop_type</span><span class="o">::</span><span class="n">unwrap_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">);</span><span class="w"></span>

<span class="w">     </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">eri_mod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">submods</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;ERI Builder&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">ERI4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eri_mod</span><span class="p">.</span><span class="n">run_as</span><span class="o">&lt;</span><span class="n">pt</span><span class="o">::</span><span class="n">eri4c</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">bra</span><span class="p">,</span><span class="w"> </span><span class="n">bra</span><span class="p">,</span><span class="w"> </span><span class="n">ket</span><span class="p">,</span><span class="w"> </span><span class="n">ket</span><span class="p">);</span><span class="w"></span>

<span class="w">     </span><span class="n">type</span><span class="o">::</span><span class="n">tensor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">J</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="n">type</span><span class="o">::</span><span class="n">tensor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rho</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MOs</span><span class="p">.</span><span class="n">C</span><span class="p">();</span><span class="w"></span>
<span class="w">     </span><span class="n">rho</span><span class="p">(</span><span class="s">&quot;mu,nu&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="s">&quot;mu,i&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="s">&quot;nu,i&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="n">J</span><span class="p">(</span><span class="s">&quot;mu, nu&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rho</span><span class="p">(</span><span class="s">&quot;lambda, sigma&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ERI4</span><span class="p">(</span><span class="s">&quot;lambda, sigma, mu, nu&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">rv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">results</span><span class="p">();</span><span class="w"></span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">j_prop_type</span><span class="o">::</span><span class="n">wrap_results</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span><span class="w"> </span><span class="n">J</span><span class="p">);</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace scf</span>
</pre></div>
</div>
<p>Of importance for our current purposes is the fact that this module depends on a
submodule (for computing the four-center, electron-repulsion integrals) which is
not part of the SCF repo. Aside from that, there’s nothing too remarkable about
the implementation of this module.</p>
<p>To finish off the implementation we also need to make sure <code class="docutils literal notranslate"><span class="pre">JCanonical</span></code> is
declared in <code class="docutils literal notranslate"><span class="pre">nwx_workspace/SCF/include/scf/scf_modules.hpp</span></code> (this file should
really live in <code class="docutils literal notranslate"><span class="pre">src</span></code> and may have been moved since this documentation was
written; if it has and you’re reading this please file an issue/make a PR) and
we need to make sure our new module is added to the module manager in
<code class="docutils literal notranslate"><span class="pre">nwx_workspace/SCF/src/scf/scf_mm.cpp</span></code>. The former amounts to adding:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">DECLARE_MODULE</span><span class="p">(</span><span class="n">JCanonical</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>to <code class="docutils literal notranslate"><span class="pre">nwx_workspace/SCF/include/scf/scf_modules.hpp</span></code> and the latter requires
adding:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">mm</span><span class="p">.</span><span class="n">add_module</span><span class="o">&lt;</span><span class="n">JCanonical</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;A key users will use to request your module&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>to <code class="docutils literal notranslate"><span class="pre">nwx_workspace/SCF/src/scf/scf_mm.cpp</span></code>.</p>
<section id="running-the-module">
<h3>Running the Module<a class="headerlink" href="#running-the-module" title="Permalink to this heading"></a></h3>
<p>Now that we wrote the module we need to test/run it. Since our module needs
integrals, and integrals are not provided by the SCF repo, we can’t simply add a
unit test to <code class="docutils literal notranslate"><span class="pre">nwx_workspace/SCF/tests</span></code> which calls our module (we’ll get to
how to unit test the module, in the SCF repo, later) because our module won’t
have integrals. How to proceed depends on whether you are ok with using a Python
script to run the calculation or if you insist on the entire development
(including running the calculation) occurring in C++ (the former is preferred
and the latter will likely be deprecated at some point).</p>
<section id="running-the-module-from-python">
<h4>Running the module from Python<a class="headerlink" href="#running-the-module-from-python" title="Permalink to this heading"></a></h4>
<p>In theory you write a Python script which looks like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">nwchemex</span> <span class="k">as</span> <span class="nn">nwx</span>

<span class="n">mm</span> <span class="o">=</span> <span class="n">nwx</span><span class="o">.</span><span class="n">sde</span><span class="o">.</span><span class="n">ModuleManager</span><span class="p">()</span>
<span class="n">nwx</span><span class="o">.</span><span class="n">load_modules</span><span class="p">(</span><span class="n">mm</span><span class="p">)</span>

<span class="c1">#We need to tell our module which ERIs to use</span>
<span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;whatever key you used in SCF for your module&quot;</span>
<span class="n">eri_key</span> <span class="o">=</span> <span class="s2">&quot;ERI4&quot;</span> <span class="c1"># or whatever 4-center ERIs you want to use</span>
<span class="n">mm</span><span class="o">.</span><span class="n">change_submod</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;ERI Builder&quot;</span><span class="p">,</span> <span class="n">eri_key</span><span class="p">);</span>

<span class="c1"># Make the input for our module</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">nwx</span><span class="o">.</span><span class="n">libchemist</span><span class="o">.</span><span class="n">Molecule</span><span class="p">()</span> <span class="c1"># Make a Molecule</span>
<span class="n">aos</span> <span class="o">=</span> <span class="n">nwx</span><span class="o">.</span><span class="n">libchemist</span><span class="o">.</span><span class="n">apply_basis</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="s2">&quot;sto-3g&quot;</span><span class="p">)</span>
<span class="n">mos</span> <span class="o">=</span> <span class="n">nwx</span><span class="o">.</span><span class="n">libchemist</span><span class="o">.</span><span class="n">DerivedSpaceD</span> <span class="c1"># get MOs from somewhere</span>

<span class="c1"># Call our module and bask in the result</span>
<span class="n">mod</span>                <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="s2">&quot;the key you put your module under&quot;</span><span class="p">)</span>
<span class="n">derived_space_type</span> <span class="o">=</span> <span class="n">nwx</span><span class="o">.</span><span class="n">scf</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">derived_space_t</span><span class="p">[</span><span class="n">double</span><span class="p">]</span>
<span class="n">j_prop_type</span>        <span class="o">=</span> <span class="n">nwx</span><span class="o">.</span><span class="n">scf</span><span class="o">.</span><span class="n">pt</span><span class="o">.</span><span class="n">coulomb</span><span class="p">[</span><span class="n">double</span><span class="p">,</span> <span class="n">derived_space_type</span><span class="p">]</span>
<span class="n">J</span>                  <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">run_as</span><span class="p">[</span><span class="n">j_prop_type</span><span class="p">](</span><span class="n">mol</span><span class="p">,</span> <span class="n">mos</span><span class="p">,</span> <span class="n">aos</span><span class="p">,</span> <span class="n">aos</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
</pre></div>
</div>
<p>Assuming <code class="docutils literal notranslate"><span class="pre">nwx.load_modules()</span></code> is written in Python, you then would simply need
to recompile <code class="docutils literal notranslate"><span class="pre">nwx_workspace/SCF</span></code> and run the above Python script. Python would
take care of all of the dynamic linking etc.</p>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>Finish/write this section when NWX’s Python bindings allow this workflow.</p>
</div>
</section>
<section id="running-the-module-from-c">
<h4>Running the module from C++<a class="headerlink" href="#running-the-module-from-c" title="Permalink to this heading"></a></h4>
<p>To run our module from C++ the eaiest way is to add a validation test to the
NWChemEx repo, say <code class="docutils literal notranslate"><span class="pre">nwx_workspace/NWChemEx/tests/j_canonical.cpp</span></code>. The
contents of this validation test look something like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;catch2/catch.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;nwchemex/load_modules.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;scf/property_types.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;scf/types.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">scf</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">j_prop_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pt</span><span class="o">::</span><span class="n">coulomb</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="o">::</span><span class="n">derived_space_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>

<span class="n">TEST_CASE</span><span class="p">(</span><span class="s">&quot;Canonical J&quot;</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">sde</span><span class="o">::</span><span class="n">ModuleManager</span><span class="w"> </span><span class="n">mm</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">nwx</span><span class="o">::</span><span class="n">load_modules</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// We need to tell our module which ERIs to use</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">key</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;whatever key you used in SCF for your module&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">eri_key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ERI4&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// or whatever 4-center ERIs you want</span>
<span class="w">    </span><span class="n">mm</span><span class="p">.</span><span class="n">change_submod</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ERI Builder&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">eri_key</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Make the input for our module</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">mol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">;</span><span class="c1">// Make a Molecule</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">aos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libchemist</span><span class="o">::</span><span class="n">apply_basis</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;sto-3g&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">mos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">;</span><span class="c1">// get MOs from somewhere</span>

<span class="w">    </span><span class="c1">// Call our module and bask in the result</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">mod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mm</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;the key you put your module under&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">J</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mod</span><span class="p">.</span><span class="n">run_as</span><span class="o">&lt;</span><span class="n">j_prop_type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span><span class="w"> </span><span class="n">mos</span><span class="p">,</span><span class="w"> </span><span class="n">aos</span><span class="p">,</span><span class="w"> </span><span class="n">aos</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>With this validation test written, we then compile <code class="docutils literal notranslate"><span class="pre">nwx_workspace/NWChemEx</span></code>,
and run the tests in <code class="docutils literal notranslate"><span class="pre">nwx_workspace/NWChemEx</span></code>. <em>N.B.</em>, we are not compiling
the SCF repo; if the toolchain file is setup correctly building
<code class="docutils literal notranslate"><span class="pre">nwx_workspace/NWChemEx</span></code> will use our local, modified, copy of SCF.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>After development is complete you should add the <code class="docutils literal notranslate"><span class="pre">mm.change_submod</span></code> line
to the <code class="docutils literal notranslate"><span class="pre">NWChemEx/src/nwchemex/load_modules.cpp</span></code> file. So that the module is
ready to be used outside of just the validation test.</p>
</div>
</section>
</section>
<section id="unit-testing-the-module">
<h3>Unit Testing the Module<a class="headerlink" href="#unit-testing-the-module" title="Permalink to this heading"></a></h3>
<p>It’s sometimes easier to get a module working using “real” data, which is what
the previous section focused on. That said the unit test for our module should
live in the SCF repo and not be coupled to the module used to get the integrals,
<em>i.e.</em>, if the integrals module breaks/changes we don’t want it break our
module’s unit test too. To avoid this coupling in our module’s unit test we use
a lambda module, which wraps some hard-coded data.</p>
<p>To start with we create a source file <code class="docutils literal notranslate"><span class="pre">nwx_workspace/SCF/tests/jcanonical.cpp</span></code>
with the contents:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;catch2/catch.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;scf/scf_mm.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;scf/property_types.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;scf/types.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sde/lambda_module.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">scf</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">j_prop_type</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">pt</span><span class="o">::</span><span class="n">coulomb</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="o">::</span><span class="n">derived_space_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">eri_prop_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pt</span><span class="o">::</span><span class="n">eri4c</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="n">TEST_CASE</span><span class="p">(</span><span class="s">&quot;Canonical J&quot;</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">sde</span><span class="o">::</span><span class="n">ModuleManager</span><span class="w"> </span><span class="n">mm</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">scf</span><span class="o">::</span><span class="n">load_modules</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Make the input for our module</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">mol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">;</span><span class="c1">// Make a Molecule</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">aos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libchemist</span><span class="o">::</span><span class="n">apply_basis</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;sto-3g&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">mos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">;</span><span class="c1">// get MOs from somewhere</span>

<span class="w">    </span><span class="c1">// Make the lambda module which will serve as the submodule</span>
<span class="w">    </span><span class="n">type</span><span class="o">::</span><span class="n">tensor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">eris</span><span class="p">;</span><span class="w"> </span><span class="c1">// hard-coded ERIS, in practice need state</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bra1</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bra2</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ket1</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ket2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Make sure our module passes the right info to the submodule</span>
<span class="w">        </span><span class="n">REQUIRE</span><span class="p">(</span><span class="n">bra1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">aos</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">REQUIRE</span><span class="p">(</span><span class="n">bra2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">aos</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">REQUIRE</span><span class="p">(</span><span class="n">ket1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">aos</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">REQUIRE</span><span class="p">(</span><span class="n">ket2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">aos</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// It did so return the hard coded result</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">eris</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">submod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sde</span><span class="o">::</span><span class="n">make_lambda</span><span class="o">&lt;</span><span class="n">eri_prop_type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span><span class="w"></span>


<span class="w">    </span><span class="c1">// Tell our module to use the lambda module</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">key</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;whatever key you used in SCF for your module&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mm</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">key</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">mod</span><span class="p">.</span><span class="n">change_submod</span><span class="p">(</span><span class="s">&quot;ERI Builder&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">submod</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Call our module and compare J to the correct value</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">J</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mod</span><span class="p">.</span><span class="n">run_as</span><span class="o">&lt;</span><span class="n">j_prop_type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span><span class="w"> </span><span class="n">mos</span><span class="p">,</span><span class="w"> </span><span class="n">aos</span><span class="p">,</span><span class="w"> </span><span class="n">aos</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>We now build <code class="docutils literal notranslate"><span class="pre">nwx_workspace/SCF</span></code> and run its tests to ensure our module works
correctly. In particular note that this test is self-contained in that it should
only fail if the implementation of our module changes (ignoring infrastructure
breaks).</p>
<p>Neding hard-coded data for unit tests is very common which is why we made the
<code class="docutils literal notranslate"><span class="pre">NWChemEx-Project/testing</span></code> repo
(<a class="reference external" href="https://github.com/NWChemEx-Project/testing">https://github.com/NWChemEx-Project/testing</a>). You are encouraged to use that
data when it makes sense.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For developers who prefer test-based development it’s entirely possible to
start with these unit tests and then to proceed to the validation tests with
real integrals modules.</p>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="preliminaries.html" class="btn btn-neutral float-left" title="Preliminaries" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ides/index.html" class="btn btn-neutral float-right" title="Using IDEs to Develop NWX" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, NWChemEx Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>