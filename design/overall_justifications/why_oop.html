<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Why Object-Oriented Programming? &mdash; DeveloperTools 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Sure it Looks Pretty, But is it Going to Scale?" href="will_this_perform.html" />
    <link rel="prev" title="Overall Design Justification" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> DeveloperTools
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../conventions/index.html">Project Conventions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Design Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../philosophy.html">Design Philosophy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nwx_ecosystem.html">NWChemEx Ecosystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overall_design.html">Overall Design</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Overall Design Justification</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Why Object-Oriented Programming?</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#fp-vs-oop">FP vs OOP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#so-why-oop">So Why OOP?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="will_this_perform.html">Sure it Looks Pretty, But is it Going to Scale?</a></li>
<li class="toctree-l3"><a class="reference internal" href="why_cxx.html">Why is C++ the Primary Language of NWChemEx?</a></li>
<li class="toctree-l3"><a class="reference internal" href="why_python.html">Why is the NWChemEx API Written in Python?</a></li>
<li class="toctree-l3"><a class="reference internal" href="one_repo_vs_many.html">Why not Just Have One Giant Repo?</a></li>
<li class="toctree-l3"><a class="reference internal" href="why_pluginplay.html">Why Do We Need PluginPlay?</a></li>
<li class="toctree-l3"><a class="reference internal" href="why_simde.html">Why Do We Need SimDE?</a></li>
<li class="toctree-l3"><a class="reference internal" href="why_chemcache.html">Why Do We Need ChemCache?</a></li>
<li class="toctree-l3"><a class="reference internal" href="why_mokup.html">Why Do We Need Mokup?</a></li>
<li class="toctree-l3"><a class="reference internal" href="why_this_partitioning.html">Why are the Repositories Partitioned this Way?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../energy_workflow.html">Energy Workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faqs.html">FAQs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../development/index.html">Developing NWChemEx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../project_management/index.html">Project Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources/index.html">Additional Developer Resources</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">DeveloperTools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Design Documentation</a> &raquo;</li>
          <li><a href="index.html">Overall Design Justification</a> &raquo;</li>
      <li>Why Object-Oriented Programming?</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/design/overall_justifications/why_oop.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="why-object-oriented-programming">
<span id="id1"></span><h1>Why Object-Oriented Programming?<a class="headerlink" href="#why-object-oriented-programming" title="Permalink to this heading"></a></h1>
<p>The decision has been made to use object-oriented programming (OOP) throughout
NWChemEx. This page explains why.</p>
<p>The summary: OOP is, in our opinion, easier to use for encapsulation and
extending the code.</p>
<p>Dating back to the earliest electronic structure codes, there has been a strong
propensity for using functional programming (FP) paradigms. Even some of the
modern codes which purport to adhere to OOP have very strong FP components (vide
infra). Furthermore, FP is the work horse of high-performance computing (HPC).
So why go against the grain?</p>
<section id="fp-vs-oop">
<h2>FP vs OOP<a class="headerlink" href="#fp-vs-oop" title="Permalink to this heading"></a></h2>
<p>Let’s start with the difference between FP and OOP. For this purpose let’s
consider a simple application. We want:</p>
<ul class="simple">
<li><p>A general API for computing the area of a shape</p></li>
<li><p>For simplicity we only worry about squares and triangles, but the design
should be extensible.</p></li>
<li><p>Computing the area should be a separate concern from determining which formula
to use (if computing the area was harder this would make it easier to optimize
a specific area formula without disturbing the rest of the code).</p></li>
</ul>
<p>The FP approach may come up with something like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">triangle_area</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">double</span><span class="w"> </span><span class="nf">square_area</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">double</span><span class="w"> </span><span class="nf">compute_area</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n_sides</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">n_sides</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">triangle_area</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="k">else</span><span class="p">(</span><span class="n">n_sides</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">square_area</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* if you get here raise an error in your favorite way (error code, or</span>
<span class="cm">       crash)*/</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>and the OOP approach might come up with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Shape</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Shape</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_base</span><span class="p">(</span><span class="n">base</span><span class="p">),</span><span class="w"> </span><span class="n">m_height</span><span class="p">(</span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">compute_area</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">m_base</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">m_height</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Triangle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Triangle</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Shape</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">compute_area</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_base</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_height</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Square</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Square</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Shape</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">compute_area</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_base</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_height</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The primary difference between the approaches is that in the FP approach the
problem is solved primarily by using functions, whereas in the OOP approach its
solved by defining and implementing objects.</p>
<p>Comparing the two examples one may note:</p>
<ul class="simple">
<li><p>Both succeed in achieving the desired encapsulation</p></li>
<li><p>Extending either approach is about the same amount of work (define a new
function, register it)</p></li>
<li><p>The FP approach is arguably simpler (less lines, no abstractions)</p></li>
<li><p>The OOP is less-coupled (can just derive a new class, no need to
change <code class="docutils literal notranslate"><span class="pre">Shape</span></code>). The FP approach requires modifying the <code class="docutils literal notranslate"><span class="pre">compute_area</span></code>.</p></li>
</ul>
<p>Admittedly one may try to dismiss the last point by pointing out that
<code class="docutils literal notranslate"><span class="pre">compute_area</span></code> could be modified to take a list of callbacks and a list of
what shape those callbacks are for. This is a valid point; however, it’s perhaps
worth nothing this is basically a manual implementation of inheritance and
arguably brings with it the complexities of OOP most FP programmers are trying
to avoid in the first place.</p>
<section id="additional-fp-vs-oop-remarks">
<h3>Additional FP vs. OOP Remarks<a class="headerlink" href="#additional-fp-vs-oop-remarks" title="Permalink to this heading"></a></h3>
<p>Particularly if you look at an article like
<a class="reference external" href="https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">this one</a>,
you may see a number of additional FP vs. OOP comparisons. Largely based on the
aforementioned article some of the other comparisons between FP and OOP are:</p>
<ul class="simple">
<li><p>OOP languages tend to have more language options</p></li>
<li><p>OOP tends to have shared mutable state</p></li>
<li><p>OOP is harder to refactor</p></li>
<li><p>OOP is harder to unit test</p></li>
</ul>
</section>
</section>
<section id="so-why-oop">
<h2>So Why OOP?<a class="headerlink" href="#so-why-oop" title="Permalink to this heading"></a></h2>
<p>The discussion above is heavily biased against OOP, so why would we still
want to use it vs. FP?</p>
<p>First, it is worth noting that design plays a huge role in how good a code is.
A well thought out design avoids many of the OOP criticisms stated above. As
evidenced by many of the legacy codes in the field of electronic structure
theory, FP alone will not make up for bad (or lack of a) design. For example,
many of the legacy electronic structure codes have resorted to shared state to
avoid massive refactoring efforts (keep in mind files are shared state…) and
many of them have gotten so coupled that refactoring is impractical. Perhaps
you might argue that it’s harder to design a code which relies on OOP than on
FP. At least for our purposes, this is a bit of a moot point, since if you’re
reading this then you don’t have to worry about designing NWChemEx because it’s
already been designed (and we’ll toot our own horn and claim that the design is
good).</p>
<p>Despite criticisms to the contrary, the main reason we have opted for OOP is
that we feel that using OOP it is far easier to encapsulate state than with FP.
At the end of the day, there is some set of inputs that each underlying
algorithm needs in order to function. As the underlying algorithm evolves that
set of inputs may change (think targeting new platforms, better approximations,
etc.). With strict FP the only way for the function to get that additional state
is to modify the call signature (or use some shared state, which we want to
avoid); unfortunately, if you modify the signature of a low-lying function you
often need to modify the signatures of all of the calling functions. With OOP
you can simply add a member variable to the object and be on your way. The
caveat is that it should make sense to add that member to one of the objects,
e.g. letting a triangle forecast the weather doesn’t make much sense from a
design standpoint; if your function takes triangles and needs to forecast the
weather then you probably should just admit that the original design missed a
use case and add another field to the function. But doesn’t that make it more
complicated? Strictly speaking, it’s not any more complicated than the FP
approach. You now have one additional piece of data and each function touching
that data can choose to use it or ignore it.</p>
<p>Another major reason for opting for OOP is ease of extension. We want
NWChemEx to be extendable. Science is continually evolving and the code needs to
evolve with it. Inheritance is minimally invasive and can be done without
modifying the source code. When combined with the encapsulation point, this
means extension is easier because developers only need to worry about
implementing the function they are overriding in the context of the provided
state.</p>
<p>Some other reasons:</p>
<ul class="simple">
<li><p>For better or worse OOP is also familiar to the current generation of
programmers.</p></li>
<li><p>In HPC there is a move to C++/Python which are object-oriented languages.
Using C++/Python lets us better capitalize on other libraries</p></li>
</ul>
<p>That all said, most developers of NWChemEx will be writing plugins; since
plugins can be written in either C++ or Python (and both languages support OOP
and FP) those developers can use OOP or FP paradigms in their plugin. The point
being the decision to use OOP primarily affects the developers of the NWChemEx
infrastructure, not plugin developers who are free to make their own decisions
(although the latter do have to contend with it at the APIs).</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Overall Design Justification" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="will_this_perform.html" class="btn btn-neutral float-right" title="Sure it Looks Pretty, But is it Going to Scale?" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, NWChemEx Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>